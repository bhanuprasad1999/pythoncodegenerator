# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>from timesformer.utils.env import setup_environment<N><N>setup_environment()<N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>import os<N>import random<N>import torch<N>import torch.utils.data<N>from fvcore.common.file_io import PathManager<N><N>import timesformer.utils.logging as logging<N><N>from . import decoder as decoder<N>from . import utils as utils<N>from . import video_container as container<N>from .build import DATASET_REGISTRY<N>logger = logging.get_logger(__name__)<N><N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>"""Data loader."""<N><N>import itertools<N>import numpy as np<N>import torch<N>from torch.utils.data._utils.collate import default_collate<N>from torch.utils.data.distributed import DistributedSampler<N>from torch.utils.data.sampler import RandomSampler<N><N>from timesformer.datasets.multigrid_helper import ShortCycleBatchSampler<N><N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>import json<N>import numpy as np<N>import os<N>import random<N>from itertools import chain as chain<N>import torch<N>import torch.utils.data<N>from fvcore.common.file_io import PathManager<N><N>import timesformer.utils.logging as logging<N><N>from . import utils as utils<N>from .build import DATASET_REGISTRY<N><N>logger = logging.get_logger(__name__)<N><N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>from .build import DATASET_REGISTRY, build_dataset  # noqa<N>from .kinetics import Kinetics  # noqa<N>from .ssv2 import Ssv2  # noqa<N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N><N>"""A More Flexible Video models."""<N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N># Copyright 2020 Ross Wightman<N># Modified model creation / weight loading / state_dict helpers<N><N>import logging<N>import os<N>import math<N>from collections import OrderedDict<N>from copy import deepcopy<N>from typing import Callable<N><N>import torch<N>import torch.nn as nn<N>import torch.utils.model_zoo as model_zoo<N>import torch.nn.functional as F<N><N>
""" Linear layer (alternate definition)<N>"""<N>import torch<N>import torch.nn.functional as F<N>from torch import nn as nn<N><N>class Linear(nn.Linear):<N>    def forward(self, input: torch.Tensor) -> torch.Tensor:<N>        if torch.jit.is_scripting():<N>            bias = self.bias.to(dtype=input.dtype) if self.bias is not None else None<N>            return F.linear(input, self.weight.to(dtype=input.dtype), bias=bias)<N>        else:<N>            return F.linear(input, self.weight, self.bias)<N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>"""Custom operators."""<N><N>import torch<N>import torch.nn as nn<N><N><N>class Swish(nn.Module):<N>    """Swish activation function: x * sigmoid(x)."""<N><N>    def __init__(self):<N>        super(Swish, self).__init__()<N><N>    def forward(self, x):<N>        return SwishEfficient.apply(x)<N><N><N>class SwishEfficient(torch.autograd.Function):<N>    """Swish activation function: x * sigmoid(x)."""<N><N>
    @staticmethod<N>    def forward(ctx, x):<N>        result = x * torch.sigmoid(x)<N>        ctx.save_for_backward(x)<N>        return result<N><N>    @staticmethod<N>    def backward(ctx, grad_output):<N>        x = ctx.saved_variables[0]<N>        sigmoid_x = torch.sigmoid(x)<N>        return grad_output * (sigmoid_x * (1 + x * (1 - sigmoid_x)))<N><N><N>class SE(nn.Module):<N>    """Squeeze-and-Excitation (SE) block w/ Swish: AvgPool, FC, Swish, FC, Sigmoid."""<N><N>
    def _round_width(self, width, multiplier, min_width=8, divisor=8):<N>        """<N>        Round width of filters based on width multiplier<N>        Args:<N>            width (int): the channel dimensions of the input.<N>            multiplier (float): the multiplication factor.<N>            min_width (int): the minimum width after multiplication.<N>            divisor (int): the new width should be dividable by divisor.<N>        """<N>        if not multiplier:<N>            return width<N><N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>"""ResNe(X)t 3D stem helper."""<N><N>import torch.nn as nn<N><N><N>def get_stem_func(name):<N>    """<N>    Retrieves the stem module by name.<N>    """<N>    trans_funcs = {"x3d_stem": X3DStem, "basic_stem": ResNetBasicStem}<N>    assert (<N>        name in trans_funcs.keys()<N>    ), "Transformation function '{}' not supported".format(name)<N>    return trans_funcs[name]<N><N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>from .build import MODEL_REGISTRY, build_model  # noqa<N>from .custom_video_model_builder import *  # noqa<N>from .video_model_builder import ResNet, SlowFast # noqa<N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved<N>"""<N>Functions for benchmarks.<N>"""<N><N>import numpy as np<N>import pprint<N>import torch<N>import tqdm<N>from fvcore.common.timer import Timer<N><N>import timesformer.utils.logging as logging<N>import timesformer.utils.misc as misc<N>from timesformer.datasets import loader<N>from timesformer.utils.env import setup_environment<N><N>
logger = logging.get_logger(__name__)<N><N><N>def benchmark_data_loading(cfg):<N>    """<N>    Benchmark the speed of data loading in PySlowFast.<N>    Args:<N><N>        cfg (CfgNode): configs. Details can be found in<N>            lib/config/defaults.py<N>    """<N>    # Set up environment.<N>    setup_environment()<N>    # Set random seed from configs.<N>    np.random.seed(cfg.RNG_SEED)<N>    torch.manual_seed(cfg.RNG_SEED)<N><N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>"""Functions that handle saving and loading of checkpoints."""<N><N>import copy<N>import numpy as np<N>import os<N>import pickle<N>from collections import OrderedDict<N>import torch<N>from fvcore.common.file_io import PathManager<N><N>import timesformer.utils.distributed as du<N>import timesformer.utils.logging as logging<N>from timesformer.utils.c2_model_loading import get_name_convert_func<N>import torch.nn.functional as F<N><N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>"""Distributed helpers."""<N><N>import functools<N>import logging<N>import pickle<N>import torch<N>import torch.distributed as dist<N><N>_LOCAL_PROCESS_GROUP = None<N><N><N>def all_gather(tensors):<N>    """<N>    All gathers the provided tensors from all processes across machines.<N>    Args:<N>        tensors (list): tensors to perform all gather across all processes in<N>        all machines.<N>    """<N><N>
    gather_list = []<N>    output_tensor = []<N>    world_size = dist.get_world_size()<N>    for tensor in tensors:<N>        tensor_placeholder = [<N>            torch.ones_like(tensor) for _ in range(world_size)<N>        ]<N>        dist.all_gather(tensor_placeholder, tensor, async_op=False)<N>        gather_list.append(tensor_placeholder)<N>    for gathered_tensor in gather_list:<N>        output_tensor.append(torch.cat(gathered_tensor, dim=0))<N>    return output_tensor<N><N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>"""Set up Environment."""<N><N>import timesformer.utils.logging as logging<N><N>_ENV_SETUP_DONE = False<N><N><N>def setup_environment():<N>    global _ENV_SETUP_DONE<N>    if _ENV_SETUP_DONE:<N>        return<N>    _ENV_SETUP_DONE = True<N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>"""Logging."""<N><N>import atexit<N>import builtins<N>import decimal<N>import functools<N>import logging<N>import os<N>import sys<N>import simplejson<N>from fvcore.common.file_io import PathManager<N><N>import timesformer.utils.distributed as du<N><N><N>def _suppress_print():<N>    """<N>    Suppresses printing from the current process.<N>    """<N><N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>"""Meters."""<N><N>import datetime<N>import numpy as np<N>import os<N>from collections import defaultdict, deque<N>import torch<N>from fvcore.common.timer import Timer<N>from sklearn.metrics import average_precision_score<N><N>import timesformer.utils.logging as logging<N>import timesformer.utils.metrics as metrics<N>import timesformer.utils.misc as misc<N><N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>import json<N>import logging<N>import math<N>import numpy as np<N>import os<N>from datetime import datetime<N>import psutil<N>import torch<N>from fvcore.common.file_io import PathManager<N>from fvcore.nn.activation_count import activation_count<N>from fvcore.nn.flop_count import flop_count<N>from matplotlib import pyplot as plt<N>from torch import nn<N><N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>import logging as log<N>import math<N>import os<N>import matplotlib.pyplot as plt<N>import torch<N>from torch.utils.tensorboard import SummaryWriter<N>from torchvision.utils import make_grid<N><N>import timesformer.utils.logging as logging<N>import timesformer.visualization.utils as vis_utils<N>from timesformer.utils.misc import get_class_names<N><N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved<N>"""<N>A script to benchmark data loading.<N>"""<N><N>import timesformer.utils.logging as logging<N>from timesformer.utils.benchmark import benchmark_data_loading<N>from timesformer.utils.misc import launch_job<N>from timesformer.utils.parser import load_config, parse_args<N><N>logger = logging.get_logger(__name__)<N><N><N>def main():<N>    args = parse_args()<N>    cfg = load_config(args)<N><N>
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.<N><N>"""Wrapper to train and test a video classification model."""<N>from timesformer.utils.misc import launch_job<N>from timesformer.utils.parser import load_config, parse_args<N><N>from tools.test_net import test<N>from tools.train_net import train<N><N><N>def get_func(cfg):<N>    train_func = train<N>    test_func = test<N>    return train_func, test_func<N><N>
import json<N>import os<N>from dotenv import load_dotenv<N><N>load_dotenv()<N><N>toJSON = {<N>    "image_path": "image.jpg",<N>    "image_start_coords": [<N>        int(json.loads(os.getenv("ENV_DRAW_X_START"))),<N>        int(json.loads(os.getenv("ENV_DRAW_Y_START"))),<N>    ],<N>    "thread_delay": 3,<N>    "unverified_place_frequency": False,<N>    "proxies": None,<N>    "workers": {},<N>}<N><N>
import math<N><N>import requests<N>import json<N>import time<N>import threading<N>import sys<N>from io import BytesIO<N>from http import HTTPStatus<N>from websocket import create_connection<N>from websocket._exceptions import WebSocketConnectionClosedException<N>from PIL import Image<N><N>from loguru import logger<N>import click<N>from bs4 import BeautifulSoup<N><N><N>from src.mappings import ColorMapper<N>import src.proxy as proxy<N>import src.utils as utils<N><N>
import nox<N><N>locations = "main.py", "noxfile.py", "src/mappings.py", "src/proxy.py", "src/utils.py"<N><N><N># This is not run automatically<N>@nox.session<N>def black(session):<N>    args = session.posargs or locations<N>    session.install("black")<N>    session.run("black", *args)<N><N><N>@nox.session<N>def lint(session):<N>    args = session.posargs or locations<N>    session.install("flake8", "flake8-black")<N>    session.run("flake8", *args)<N><N><N>nox.options.sessions = ["lint"]<N>
import json<N>import os<N>from PIL import Image, UnidentifiedImageError<N><N><N>def get_json_data(self, config_path):<N>    configFilePath = os.path.join(os.getcwd(), config_path)<N><N>    if not os.path.exists(configFilePath):<N>        exit("No config.json file found. Read the README")<N><N>    # To not keep file open whole execution time<N>    f = open(configFilePath)<N>    json_data = json.load(f)<N>    f.close()<N><N>
    return json_data<N><N>    # Read the input image.jpg file<N><N><N>def load_image(self):<N>    # Read and load the image to draw and get its dimensions<N>    try:<N>        im = Image.open(self.image_path)<N>    except FileNotFoundError:<N>        self.logger.exception("Failed to load image")<N>        exit()<N>    except UnidentifiedImageError:<N>        self.logger.exception("File found, but couldn't identify image format")<N><N>
